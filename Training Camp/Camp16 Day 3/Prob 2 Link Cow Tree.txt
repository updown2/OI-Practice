#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define For(i, a, b) for(int i=a; i<b; i++)
#define ffi For(i, 0, N)
#define ffj For(j, 0, M)
#define ffa ffi ffj
#define s <<" "<<
#define w cout
#define e "\n"
#define pb push_back
#define mp make_pair
#define a first
#define b second
//#define int ll
const int MAXN=200001, INF=10000000000;
///500,000,000
int N, Q;
vector<int> tree[4*MAXN+1], adj[MAXN];

void build (int ind, int L, int R) {
    if (L == R) {
        for (int i: adj[L]) tree[ind].pb(i);
        sort(tree[ind].begin(), tree[ind].end());
        return;
    }
    build(ind*2, L, (L+R)/2), build(ind*2+1, (L+R)/2+1, R);
    for (int i: tree[ind*2]) tree[ind].pb(i);
    for (int i: tree[ind*2+1]) tree[ind].pb(i);
    sort(tree[ind].begin(), tree[ind].end());
}
int query(int ind, int L, int R, int qL, int qR) {
    if (R < qL || qR < L) return 0;
    if (qL <= L && R <= qR) {
        /// find max a st tree[ind][a] < qL
        int a = -1, b = tree[ind].size()-1;
        while (a != b) {
            int mid = (a+b+1)/2;
            if (tree[ind][mid] < qL) a = mid;
            else b = mid-1;
        }
        int st = a+1;
        //for (int i: tree[ind]) w<< i<< " "; w<<e;
        /// find min a st tree[ind][a] > qR
        a = 0, b = tree[ind].size();
        while (a != b) {
            int mid = (a+b)/2;
            if (tree[ind][mid] > qR) b = mid;
            else a = mid+1;
        }
        int en = a-1;
        //w<< "total" s L s R s "," s qL s qR s ":" s en-st+1<<e;
        return en-st+1;
    }
    return query(ind*2, L, (L+R)/2, qL, qR) + query(ind*2+1, (L+R)/2+1, R, qL, qR);
}

main() {
	//ifstream cin("test.in");
	ios_base::sync_with_stdio(0); cin.tie(0);
	cin >> N >> Q;
	For (i, 1, N) {
        int a, b; cin >> a >> b;
        adj[a].pb(b);
	}
	build (1, 1, N);
	For (q, 0, Q) {
        int a, b; cin >> a >> b;
        if (b < a) swap(a, b);
        w<< 1 + b-a -query(1, 1, N, a, b)<<e;
	}
}