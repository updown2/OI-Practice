#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int ll
#define For(i, a, b) for(int i=a; i<b; i++)
#define ffi For(i, 0, N)
#define ffj For(j, 0, N)
#define w cout
#define e "\n"
#define s <<" "<<
#define a first
#define b second
#define pb push_back
#define pf push_front
#define mp make_pair
#define int ll
const int MAXN = 100000, INF=10000000, MOD = 1000000007;
////////////////////////////////////////////////////////
int N, Q, nums[MAXN], on[4*MAXN+1], lazy[4*MAXN+1];

void push(int ind, int L, int R) {
	if (lazy[ind] == 0) return;
	on[ind] += lazy[ind]* (R-L+1); /// May have to change
	on[ind] %= MOD;
	if (L != R) {
		lazy[ind*2] += lazy[ind];
		lazy[ind*2] %= MOD;
		lazy[ind*2+1] += lazy[ind];
		lazy[ind*2+1] %= MOD;
	}
	lazy[ind] = 0;
}

void build (int index, int L, int R) {
	if (L == R) on[index] = nums[L];
	else {
		build(index*2, L, (L+R)/2);
		build(index*2+1, 1+(L+R)/2, R);
		on[index] = (on[index*2] + on[index*2+1])%MOD;
	}
}
int query (int index, int L, int R, int oL, int oR) {
	push(index, L, R);
	if ( (oR < L) || (oL > R) ) return 0;
	if ( (R <= oR) && (L >= oL) ) return on[index];

	return (query(index*2, L, (L+R)/2, oL, oR) + query(index*2+1, 1+(L+R)/2, R, oL, oR ))%MOD;
}
void update_range (int index, int L, int R, int a, int b, int v) {
	push(index, L, R);
	if (b<L || a>R) return;
	else if (a<=L && R<= b) {
		lazy[index] = v;
		push(index, L, R);
	}
	else {
		update_range(index*2, L, (L+R)/2, a, b, v);
		update_range(index*2+1, 1+(L+R)/2, R, a, b, v);
		on[index] = (on[index*2]+on[index*2+1])%MOD;
	}
}


main() {
	//ifstream cin ("test.in");
	ios_base::sync_with_stdio(0); cin.tie(0);
	cin >> N >> Q;
	ffi cin >> nums[i];
	build(1, 0, N-1);

	int a, b, c, d;
	For (i, 0, Q) {
		cin >> a >> b >> c; b--; c--;
		if (a == 1) cout << query(1, 0, N-1, b, c) << endl;
		else {
            cin >> d;
			update_range(1, 0, N-1, b, c, d);
		}
	}
}