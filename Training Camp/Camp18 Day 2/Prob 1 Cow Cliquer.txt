#include <bits/stdc++.h>
#include "grader.h"
using namespace std;
typedef long long ll;
#define For(i, a, b) for(int i=a; i<b; i++)
#define ffi For(i, 1, N+1)
#define ffj For(j, 0, N)
#define ffa ffi ffj
#define s <<" "<<
#define w cout
#define e endl
#define pb push_back
#define mp make_pair
#define a first
#define b second
//#define int ll
//500,000,000 operations
const int MAXN = 500000;
//Global Variables
int N;
vector<int> rp[MAXN], sp[MAXN], tim[MAXN];
map<string, int> ind;

int get(string cow) {
    if (ind.find(cow) == ind.end()) {
        ind[cow] = N;
        rp[N].pb(N);
        sp[N].pb(1);
        tim[N].pb(0);
        N++;
    }
    return ind[cow];
}
int up (int x, int t) {
    /// get the index of the time
    int a = 0, b = tim[x].size()-1;
    while (a != b) {
        int mid = (a+b+1)/2;
        if (tim[x][mid] <= t) a = mid;
        else b = mid-1;
    }
    /// root at the time
    int y = rp[x][a];
    if (x == y) return x; /// found the very top root
    return up(y, t); /// look for higher root
}
int calc_size (int x, int t) {
    x = up(x, t); /// find root at the time
    /// get index of the time
    int a = 0, b = tim[x].size()-1;
    while (a != b) {
        int mid = (a+b+1)/2;
        if (tim[x][mid] <= t) a = mid;
        else b = mid-1;
    }
    /// return the size at the time
    return sp[x][a];
}

void add_friend(string cow1, string cow2, int timestamp) {
    int a = get(cow1), b = get(cow2); /// gets the index
    a = up(a, timestamp), b = up(b, timestamp); /// root at the time (should be current)
    if (a == b) return; /// root are the same
    int s1 = calc_size(a, timestamp), s2 = calc_size(b, timestamp); /// size at the time (should be current)
    /*w<< "BEFORE" s a s b s ":" s timestamp<<e;
    w<< a << ":"<<e;
    for (int i: rp[a]) w<< i << " "; w<<e;
    for (int i: sp[a]) w<< i << " "; w<<e;
    for (int i: tim[a]) w<< i << " "; w<<e;
    w<< b << ":"<<e;
    for (int i: rp[b]) w<< i << " "; w<<e;
    for (int i: sp[b]) w<< i << " "; w<<e;
    for (int i: tim[b]) w<< i << " "; w<<e;*/
    /// merge a into b
    if (s1 < s2) {
        rp[a].pb(b);
        sp[a].pb(s1);
        tim[a].pb(timestamp);
        rp[b].pb(b);
        sp[b].pb(s1+s2);
        tim[b].pb(timestamp);
    }
    /// merge b into a
    else {
        rp[b].pb(a);
        sp[b].pb(s2);
        tim[b].pb(timestamp);
        rp[a].pb(a);
        sp[a].pb(s1+s2);
        tim[a].pb(timestamp);
    }
    /*w<< "AFTER" s a s b s ":" s timestamp<<e;
    w<< a << ":"<<e;
    for (int i: rp[a]) w<< i << " "; w<<e;
    for (int i: sp[a]) w<< i << " "; w<<e;
    for (int i: tim[a]) w<< i << " "; w<<e;
    w<< b << ":"<<e;
    for (int i: rp[b]) w<< i << " "; w<<e;
    for (int i: sp[b]) w<< i << " "; w<<e;
    for (int i: tim[b]) w<< i << " "; w<<e;*/
}
bool check_friend(string cow1, string cow2, int timestamp) {
    int a = up(get(cow1), timestamp), b = up(get(cow2), timestamp);
    return a == b;
}
int get_number_of_friends(string cow, int timestamp) {
    return calc_size(get(cow), timestamp);
}

/*
int main() {
    ifstream cin("test.in");
  int num_commands;
  cin >> num_commands;

  for (int i = 0; i < num_commands; ++i) {
    string command_type;
    cin >> command_type;

    if (command_type == "A") {
      std::string cow1, cow2;
      int timestamp;
      cin >> cow1 >> cow2 >> timestamp;

      add_friend(cow1, cow2, timestamp);
    } else if (command_type == "C") {
      std::string cow1, cow2;
      int timestamp;
      cin >> cow1 >> cow2 >> timestamp;

      std::string responses[] = {"FALSE", "TRUE"};
      std::cout << responses[check_friend(cow1, cow2, timestamp)] << std::endl;
    } else if (command_type == "N") {
      std::string cow;
      int timestamp;
      cin >> cow >> timestamp;

      cout << get_number_of_friends(cow, timestamp) << std::endl;
    } else {
      std::cout << "Invalid command type: " << command_type << std::endl;
      exit(1);
    }
  }
}*/
