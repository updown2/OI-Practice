#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define For(i, a, b) for(int i=a; i<b; i++)
#define ffi For(i, 0, N)
#define ffj For(j, 0, M)
#define ffa ffi ffj
#define s <<" "<<
#define w cout
#define e endl
#define pb push_back
#define mp make_pair
#define a first
#define b second
#define int ll
//500,000,000 operations
const int MAXN = 100000;
//Global Variables
int N, M, loc[MAXN], dist[MAXN], far[MAXN];
vector<int> adj[MAXN], ppp;
bool vis[MAXN], path[MAXN];
set<int> out;

void find_path(int at) {
    vis[at] = true;
    //w<< at+1<<e;
    if (at == N-1) {path[at] = true; ppp.pb(at); return;}
    for (int i: adj[at]) if (!vis[i]) {
        find_path(i);
        if (path[i]) {path[at] = true; ppp.pb(at); return;}
    }
}

int go(int at, bool start) {
    //w<< at +1 <<e;
    if (path[at] && !start) return dist[at];
    if (vis[at]) return 0;
    vis[at] = true;
    int ret = 0;
    for (int i: adj[at]) ret = max(ret, go(i, false));
    //w<< at+1 s ":" s ret<<e;
    return ret;
}

main() {
    //ifstream cin("test.in");
	ios_base::sync_with_stdio(0); cin.tie(0);
	cin >> N >> M;
	ffj {int a, b; cin >> a >> b; a--; b--; adj[a].pb(b);}
	find_path(0);
	//ffi w<< i+1 s ":" s path[i]<<e;
	ffi vis[i] = false;
	reverse(ppp.begin(), ppp.end());
	//for (int i: ppp) w<< i+1<<e;
	For (i, 0, ppp.size()) dist[ppp[i]] = i;
	For (i, 0, ppp.size()) {
	    int x = ppp[i];
	    //w<< "starting from" s x+1<<e;
        if (i == 0) far[x] = go(x, true);
        else far[x] = max(go(x, true), far[ppp[i-1]]);
	}
	//ffi w<< i+1 s ":" s far[i]+1<<e;
	int at = 0;
	while (at < ppp.size()-1) {
        if (at != 0 && far[ppp[at-1]] == far[ppp[at]]) path[ppp[at]] = false;
        int x = ppp[at];
        For (j, at+1, far[x]) path[ppp[j]] = false;
        //w<< at s x s far[x]<<e;
        assert(at+1 <= far[x]);
        at = far[x];
	}
	For (i, 1, N-1) if (path[i]) out.insert(i+1);
	w<< out.size()<<e;
	for (int i: out) w<<i<<e;
}