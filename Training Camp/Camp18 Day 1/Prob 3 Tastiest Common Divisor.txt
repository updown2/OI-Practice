#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define For(i, a, b) for(int i=a; i<b; i++)
#define ffi For(i, 0, N)
#define ffj For(j, 0, at)
#define ffa ffi ffj
#define mp make_pair
#define a first
#define b second
#define w cout
#define e "\n"
#define s <<" "<<
#define int ll
///////////////////////////////////////////
const int MAXN = 100000;
/// 500,000,000
int N, Q, inp[MAXN], vals[200*MAXN][2], at; ///vals[ind] = (gcd, prefix_sum)
map<int, int> cnt;
map<int, int>::iterator it, it1, it2;

int gcd(int a, int b) {if (a == 0) return b;return gcd(b%a, a);}
void go(int a, int b) {
    if (a == b) {
        if (cnt.find(inp[a]) == cnt.end()) cnt[inp[a]] = 1;
        else cnt[inp[a]]++;
        //w<< "map" s inp[a] s ";" s cnt[inp[a]]<<e;
        return;
    }
    int mid = (a+b)/2;
    go(a, mid), go(mid+1, b);
    map<int, int> lef, rig;
    int running = 0;
    for (int i=mid; i>= a; i--) {
        running = gcd(running, inp[i]);
        if (lef.find(running) == lef.end()) lef[running] = 1;
        else lef[running]++;
    }
    //w<< mid+1 s b<<e;
    running = 0;
    For (i, mid+1, b+1) {
        running = gcd(running, inp[i]);
        if (rig.find(running) == rig.end()) rig[running] = 1;
        else rig[running]++;
        //w<< running s rig[running] <<e;
    }
    //w<<e;
    /// combine both sides
    //w<< "combing" s a s mid s "," s mid+1 s b<<e;
    for (it1 = lef.begin(); it1 != lef.end(); it1++) for (it2 = rig.begin(); it2 != rig.end(); it2++) {
        int v1 = it1->a, v2 = it2->a, c1 = it1->b, c2 = it2->b;
        int ne = gcd(v1, v2);
        //w<< v1 s v2 s ne s ":" s c1 s c2<<e;
        if (cnt.find(ne) == cnt.end()) cnt[ne] = c1*c2;
        else cnt[ne] += c1*c2;
        //w<< "map" s ne s ":" s cnt[ne]<<e;
    }
}

main () {
    //ifstream cin("test.in");
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> N >> Q;
    ffi cin >> inp[i];
    go(0, N-1);
    //for (it1 = cnt.begin(); it1 != cnt.end(); it1++) std::cout << it1->first << " => " << it1->second << '\n';
    for (it = cnt.begin(); it != cnt.end(); it++) {
        vals[at][0] = it->a;
        if (at == 0) vals[at][1] = it->b;
        else vals[at][1] = vals[at-1][1] + it->b;
        at++;
    }
    //ffj w<< vals[j][0] s vals[j][1]<<e;
    For (q, 0, Q) {
        int x, y; cin >> x >> y;
        if (vals[0][0] > y || vals[at-1][0] < x) {w<<0<<e; continue;}
        int a = 0, b = at-1;
        /// find lower bound to the range
        while (a != b) {
            int mid = (a+b)/2;
            //w<< a s b s ":" s vals[mid] s "," s x<<e;
            if (vals[mid][0] < x) a = mid+1;
            else b = mid;
        }
        int lb = a;
        //w<< "lb:" s lb<<e;

        a = 0, b = at-1;
        /// find upper bound to the range
        while (a != b) {
            int mid = (a+b+1)/2;
            if (vals[mid][0] <= y) a = mid;
            else b = mid-1;
        }
        //w<< lb s a <<e;
        if (lb > a) {w<<0<<e; continue;}
        if (lb == 0) w<< vals[a][1]<<e;
        else w<< vals[a][1] - vals[lb-1][1]<<e;
    }
}