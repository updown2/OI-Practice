#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define For(i, a, b) for(int i=a; i<b; i++)
#define ffi For(i, 0, N)
#define ffj For(j, 0, N)
#define ffa ffi ffj
#define s <<" "<<
#define w cout
#define e "\n"
#define pb push_back
#define mp make_pair
#define a first
#define b second
//#define int ll
const int MAXN=10002, INF=1000000000;
///500,000,000
int N, M, source, sink;
bool visited[MAXN];
vector<int> adj[MAXN], res[MAXN], sind[MAXN];

void connect(int a, int b, int c) {
    //w<< a s b s ":" s c<<e;
    adj[a].pb(b);
    sind[a].pb(adj[b].size());
    adj[b].pb(a);
    sind[b].pb(adj[a].size());

    res[a].pb(c);
    res[b].pb(0);
}

int dfs(int x, int cap=INF) {
    visited[x] = true;
    if (x==sink) return cap; //If you are done and can only take cap things, return cap(you're all done)
//w<< x s cap<<e;
    For (y, 0, adj[x].size()) {
        int i = adj[x][y];
        int ind = sind[x][y];

        if (!visited[i]) {
            if (res[x][y] > 0) {
                //w<< "from" s x s "to" s i<<e;
                int cur = dfs(i, min(cap, res[x][y]));
                if (cur > 0) {
                    res[x][y] -= cur;
                    res[i][ind] += cur;
                    return cur;
                }
            }
        }
    }
    return 0;
}
int maxflow() {
    //Finds the max flow from source to the sink
    int flow = 0;
    while (true) {
        ffi visited[i] = false;

        //w<<"starting"<<e;
        int cur = dfs(source);
        //w << "ended at" s cur << e;

        if (cur == 0) break;
        flow += cur;
    }
    return flow;
}

int R, C, ob, have;
char grid[100][100];
bool black[100][100];

void put(int ind1, int x, int y) {
    if (x<0 || y<0 || x>=R || y>=C) return;
    int ind2 = x*C + y;
    connect(ind1, ind2, INF);
}

main() {
    //ifstream cin ("test.in");

    cin >> R >> C;
    N = R*C+2, M = 10*R*C; ///M is edges, N is nodes
    source = R*C, sink = R*C+1;

    for (int i=0; i<R; i+= 2) black[i][0] = true;
    For (i, 0, R) For (j, 1, C) black[i][j] = !black[i][j-1];

    For (i, 0, R) For (j, 0, C) {
        cin >> grid[i][j];
        int ind = i*C+j;
        if (grid[i][j] == 'C') {
            black[i][j] ? connect(source, ind, INF) : connect(ind, sink, INF);
            have++;
        }
        else if (grid[i][j] == '.'){
            black[i][j] ? connect(source, ind, 1) : connect(ind, sink, 1);
        }
        else ob++;

        if (black[i][j]) {
            put(ind, i+1, j+2);
            put(ind, i+1, j-2);
            put(ind, i+2, j-1);
            put(ind, i+2, j+1);
            put(ind, i-1, j+2);
            put(ind, i-1, j-2);
            put(ind, i-2, j-1);
            put(ind, i-2, j+1);
        }
        //w<<e;
    }
    w<< R*C-maxflow()-ob <<e;
    //w<< maxflow()<<e;
}